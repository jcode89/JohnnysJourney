<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Johnny's Journeys</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2016-01-03T22:46:00-05:00</updated><entry><title>The Road To Rethink</title><link href="/the-road-to-rethink.html" rel="alternate"></link><updated>2016-01-03T22:46:00-05:00</updated><author><name>Jonathan Colon</name></author><id>tag:,2016-01-03:the-road-to-rethink.html</id><summary type="html">&lt;h2&gt;In The Beginning.&lt;/h2&gt;
&lt;p&gt;Learning a new language has its ups and its downs, but one thing that always holds true is, once you understand it fully you feel so accomplished. The languages I am referring to are formal languages, languages like Python. This is the language I chose to learn when I started my journey through computer science. This type of journey has no real end as there is always something new to learn, albeit new features to the language of choice, or an entirely new language altogether. This realization of, no end, came to me while I was working on a project. The focus of this project was to analyze data gathered through twitter. In order to be able to analyze this data you have to store it somewhere, this is where databases come into play.
There are many types of databases and the most common one to start out with when working with Python is SQLite. It is built into the language itself, which, makes it readily available to all Python programmers. SQLite uses the SQL query language to perform what is known as the CRUD methods. These are Create, Read, Update, Delete, and they are all essential when working with any database. Once you start to research and find new databases to work with, you will notice that most of them use a language that seemingly stems from SQL. This is often the case. Although, it is not SQL per se, the syntax is fairly similar. This is because, as every programmer knows, all databases use the same types of functions. However, how they all store data is different, and that is why I moved onto a new database.&lt;/p&gt;
&lt;h2&gt;Why RethinkDB?&lt;/h2&gt;
&lt;p&gt;This database was RethinkDB and it is open source and something referred to as NoSQL which means that it stores data in document form, usually JSON, or Javascript Object Notation. By storing the data using JSON you make it easier to retrieve. In Python one can use the syntax you use to work with dictionaries to retrieve the information. When it came time to incorporate this into my program I had a bit of a hard time as RethinkDB was different to setup and connect. I wound up having to write a function(EX.1) that connects to the database and makes sure the database and table exist, and if they do not, it creates both of them.&lt;/p&gt;
&lt;h4&gt;EX.1&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;database_connect&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;

    &lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;Creates the database and the table if it doesn&amp;#39;t already exist&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;

    &lt;span class="n"&gt;db_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;test&amp;#39;&lt;/span&gt;&lt;span class="c"&gt;# Enter name of your database&lt;/span&gt;

    &lt;span class="n"&gt;table_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;chat_test_1&amp;#39;&lt;/span&gt;&lt;span class="c"&gt;# Enter name of your table&lt;/span&gt;

    &lt;span class="n"&gt;conn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;28015&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

            &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;db_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;db_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;conn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

     &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;db_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;table_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;conn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

     &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Database setup completed!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="n"&gt;RqlRuntimeError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

     &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;db_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;table_create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table_name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;conn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

     &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Database already exists!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

        &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Database and table exist!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

        &lt;span class="n"&gt;conn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;However, as far as inserting information was concerned, I had to change very little code, but I was also able to save all of the data that twitter allowed you to see when grabbing tweets. I was able to do this because twitter sends the information in JSON format. RethinkDB, as Iâ€™ve already mentioned, stores the information in the database as a JSON object and since the data was already presented in JSON format all that was needed was a simple insert command. On the other hand, when storing information in the SQLite database I had to create columns in tables and break all the information up so that it went to the correct column. In short, it was much more tedious trying to store Twitter data in SQLite as compared to RethinkDB.
RethinkDB uses a language the creators like to call ReQL, and the syntax for ReQL is similar to SQL. So changing from SQLite to RethinkDB was even easier knowing that much of the syntax would not be changing at all. That was a big plus in my eyes. One thing RethinkDB does, that I did not include in my program as of yet, is it allows you to get updates in real time. For example, if you are following a specific hashtag, or a specific user, you could use what the creators call a changefeed(RethinkDB, 2015). What that will do is send you an alert with what changes happened to the database, so in this case you would see the new tweet. This is very useful for those who want to perform real time analytics on their data sets.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;So all in all you can see why going with RethinkDB was the better choice. SQLite is good to get you started, if you have never worked with databases before, but picking up RethinkDB is not that difficult. It also will provide the user with more room for growth because now you can update your application or program so that it performs real time analysis, or updates your site, whenever a change is detected in your database. As for my project, I know I have room to grow, and I fully intend to use everything RethinkDB has to offer.&lt;/p&gt;
&lt;h3&gt;Works Cited&lt;/h3&gt;
&lt;p&gt;RethinkDB. (2015). Changefeeds in RethinkDB. Retrieved from
    https://rethinkdb.com/docs/changefeeds/python/&lt;/p&gt;</summary></entry><entry><title>The Journey Begins</title><link href="/the-journey-begins.html" rel="alternate"></link><updated>2016-01-03T02:55:00-05:00</updated><author><name>Jonathan Colon</name></author><id>tag:,2016-01-03:the-journey-begins.html</id><summary type="html">&lt;h1&gt;Where Do I Begin?&lt;/h1&gt;
&lt;p&gt;My name is Jonathan Colon, and over the past year or so I have been developing in Python.
I love developing in Python, and just programming in general. That is why I have made it my mission
to learn more languages, mainly C and Clojure. I could never have done any of this without the support of
the &lt;strong&gt;CodeNewbie&lt;/strong&gt; community. They have helped me so much, and have been such an inspiration on my journey.
I am proud to say I am a part of the CodeNewbie community. I am also proud to say I am part of the
&lt;strong&gt;#Python_Thursday&lt;/strong&gt; crew. Together, we have inspired countless projects and helped even more Newbies realize
they have the chops to become a developer.&lt;/p&gt;
&lt;h2&gt;New Year, New Language&lt;/h2&gt;
&lt;p&gt;I have decided to learn Clojure in 2016, as well as, continue learning C and Python.
Let's face it though, every developer knows you never truly stop learning.&lt;/p&gt;
&lt;p&gt;You may be wondering why I chose to learn Clojure. Well, I have always been fascinated with Artificial Intelligence
and when you do research Lisp always seems to pop up. Since this keyword kept coming up in my research
I decided to look more into Lisp, and found that it is considered a &lt;em&gt;family of functional programming languages&lt;/em&gt;. Clojure is part of the Lisp family. Some members of the &lt;strong&gt;#Python_Thursday&lt;/strong&gt; crew decided to take up this challenge for the new year
as well. Together we know we will learn all that functional programming has to offer.&lt;/p&gt;
&lt;h2&gt;Follow Me On My Journey!&lt;/h2&gt;
&lt;p&gt;Now to the really exciting news! I am going to be writing weekly posts in regards to my journey learning Clojure, as well as,
posts updating my followers on my Python/C journey as well. As I said earlier, you never truly stop learning, so there
will always be new posts. The other goal of these posts is to show every developer, both new and old, that coding can be
challenging at times and you really just need to keep at it. You will find the solution to your problem with time and when
that time comes you will feel better than you ever have. Why? Because you did it, you were able to overcome that hurdle.&lt;/p&gt;
&lt;p&gt;I hope these posts inspire you to never give up and keep pushing ahead. See you all in the next post!&lt;/p&gt;</summary></entry></feed>